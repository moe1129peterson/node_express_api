"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_loggers_1 = require("@pnpm/core-loggers");
const logger_1 = require("@pnpm/logger");
const child_process = require("child_process");
const mkdirp = require("mkdirp-promise");
const fs = require("mz/fs");
const ncpCB = require("ncp");
const pLimit = require("p-limit");
const path = require("path");
const exists = require("path-exists");
const pathTemp = require("path-temp");
const renameOverwrite = require("rename-overwrite");
const promisify = require("util.promisify");
const linkIndexedDir_1 = require("../fs/linkIndexedDir");
const execFilePromise = promisify(child_process.execFile);
const ncp = promisify(ncpCB);
const limitLinking = pLimit(16);
exports.default = (packageImportMethod) => {
    const importPackage = createImportPackage(packageImportMethod);
    return (filesResponse, dependency, opts) => limitLinking(() => importPackage(filesResponse, dependency, opts));
};
function createImportPackage(packageImportMethod) {
    let fallbackToCopying = false;
    // this works in the following way:
    // - hardlink: hardlink the packages, no fallback
    // - reflink: reflink the packages, no fallback
    // - auto: try to hardlink the packages, if it fails, fallback to copy
    // - copy: copy the packages, do not try to link them first
    switch (packageImportMethod || 'auto') {
        case 'reflink':
            return reflinkPkg;
        case 'hardlink':
            return hardlinkPkg;
        case 'auto':
            return function importPackage(from, to, opts) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (fallbackToCopying) {
                        yield copyPkg(from, to, opts);
                        return;
                    }
                    try {
                        yield hardlinkPkg(from, to, opts);
                    }
                    catch (err) {
                        if (!err.message.startsWith('EXDEV: cross-device link not permitted'))
                            throw err;
                        logger_1.storeLogger.warn(err.message);
                        logger_1.storeLogger.info('Falling back to copying packages from store');
                        fallbackToCopying = true;
                        yield importPackage(from, to, opts);
                    }
                });
            };
        case 'copy':
            return copyPkg;
        default:
            throw new Error(`Unknown package import method ${packageImportMethod}`);
    }
}
function reflinkPkg(from, to, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJsonPath = path.join(to, 'package.json');
        if (!opts.filesResponse.fromStore || opts.force || !(yield exists(pkgJsonPath))) {
            core_loggers_1.importingLogger.debug({ from, to, method: 'reflink' });
            const staging = pathTemp(path.dirname(to));
            yield mkdirp(staging);
            yield execFilePromise('cp', ['-r', '--reflink', from + '/.', staging]);
            yield renameOverwrite(staging, to);
        }
    });
}
function hardlinkPkg(from, to, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJsonPath = path.join(to, 'package.json');
        if (!opts.filesResponse.fromStore || opts.force || !(yield exists(pkgJsonPath)) || !(yield pkgLinkedToStore(pkgJsonPath, from, to))) {
            core_loggers_1.importingLogger.debug({ from, to, method: 'hardlink' });
            yield linkIndexedDir_1.default(from, to, opts.filesResponse.filenames);
        }
    });
}
function pkgLinkedToStore(pkgJsonPath, from, to) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJsonPathInStore = path.join(from, 'package.json');
        if (yield isSameFile(pkgJsonPath, pkgJsonPathInStore))
            return true;
        logger_1.storeLogger.info(`Relinking ${to} from the store`);
        return false;
    });
}
function isSameFile(file1, file2) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield Promise.all([fs.stat(file1), fs.stat(file2)]);
        return stats[0].ino === stats[1].ino;
    });
}
function copyPkg(from, to, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJsonPath = path.join(to, 'package.json');
        if (!opts.filesResponse.fromStore || opts.force || !(yield exists(pkgJsonPath))) {
            core_loggers_1.importingLogger.debug({ from, to, method: 'copy' });
            const staging = pathTemp(path.dirname(to));
            yield mkdirp(staging);
            yield ncp(from + '/.', staging);
            yield renameOverwrite(staging, to);
        }
    });
}
exports.copyPkg = copyPkg;
//# sourceMappingURL=createImportPackage.js.map