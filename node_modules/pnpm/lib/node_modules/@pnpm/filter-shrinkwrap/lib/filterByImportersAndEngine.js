"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const package_is_installable_1 = require("@pnpm/package-is-installable");
const shrinkwrap_utils_1 = require("@pnpm/shrinkwrap-utils");
const dp = require("dependency-path");
const R = require("ramda");
const filterImporter_1 = require("./filterImporter");
const normalizeShrinkwrap_1 = require("./normalizeShrinkwrap");
const logger = logger_1.default('shrinkwrap');
function filterByImportersAndEngine(shr, importerIds, opts) {
    const importerDeps = importerIds
        .map((importerId) => shr.importers[importerId])
        .map((importer) => (Object.assign({}, (opts.include.dependencies && importer.dependencies || {}), (opts.include.devDependencies && importer.devDependencies || {}), (opts.include.optionalDependencies && importer.optionalDependencies || {}))))
        .map(R.toPairs);
    const directDepPaths = R.unnest(importerDeps)
        .map(([pkgName, ref]) => dp.refToRelative(ref, pkgName))
        .filter((nodeId) => nodeId !== null);
    const packages = shr.packages &&
        pickPkgsWithAllDeps(shr.packages, directDepPaths, {
            currentEngine: opts.currentEngine,
            defaultRegistry: opts.defaultRegistry,
            engineStrict: opts.engineStrict,
            failOnMissingDependencies: opts.failOnMissingDependencies,
            include: opts.include,
            includeIncompatiblePackages: opts.includeIncompatiblePackages === true,
            prefix: opts.prefix,
            skipped: opts.skipped,
        }) || {};
    const importers = importerIds.reduce((acc, importerId) => {
        acc[importerId] = filterImporter_1.default(shr.importers[importerId], opts.include);
        if (acc[importerId].optionalDependencies) {
            for (const depName of Object.keys(acc[importerId].optionalDependencies || {})) {
                const relDepPath = dp.refToRelative(acc[importerId].optionalDependencies[depName], depName);
                if (relDepPath && !packages[relDepPath]) {
                    delete acc[importerId].optionalDependencies[depName];
                }
            }
        }
        return acc;
    }, Object.assign({}, shr.importers));
    return normalizeShrinkwrap_1.default({
        importers,
        packages,
        registry: shr.registry,
        shrinkwrapVersion: shr.shrinkwrapVersion,
    });
}
exports.default = filterByImportersAndEngine;
function pickPkgsWithAllDeps(pkgSnapshots, relDepPaths, opts) {
    const pickedPackages = {};
    pkgAllDeps({ pkgSnapshots, pickedPackages }, relDepPaths, true, opts);
    return pickedPackages;
}
function pkgAllDeps(ctx, relDepPaths, parentIsInstallable, opts) {
    for (const relDepPath of relDepPaths) {
        if (ctx.pickedPackages[relDepPath])
            continue;
        const pkgSnapshot = ctx.pkgSnapshots[relDepPath];
        if (!pkgSnapshot && !relDepPath.startsWith('link:')) {
            const message = `No entry for "${relDepPath}" in shrinkwrap.yaml`;
            if (opts.failOnMissingDependencies) {
                const err = new Error(message);
                err['code'] = 'ERR_PNPM_SHRINKWRAP_MISSING_DEPENDENCY'; // tslint:disable-line:no-string-literal
                throw err;
            }
            logger.debug(message);
            continue;
        }
        let installable;
        const depPath = dp.resolve(opts.defaultRegistry, relDepPath);
        if (!parentIsInstallable) {
            installable = false;
            if (!ctx.pickedPackages[relDepPath]) {
                opts.skipped.add(depPath);
            }
        }
        else {
            const pkg = Object.assign({}, shrinkwrap_utils_1.nameVerFromPkgSnapshot(relDepPath, pkgSnapshot), { cpu: pkgSnapshot.cpu, engines: pkgSnapshot.engines, os: pkgSnapshot.os });
            // TODO: relDepPath is not the package ID. Should be fixed
            installable = opts.includeIncompatiblePackages || package_is_installable_1.default(pkgSnapshot.id || relDepPath, pkg, {
                engineStrict: opts.engineStrict,
                nodeVersion: opts.currentEngine.nodeVersion,
                optional: pkgSnapshot.optional === true,
                pnpmVersion: opts.currentEngine.pnpmVersion,
                prefix: opts.prefix,
            });
            if (!installable) {
                if (!ctx.pickedPackages[relDepPath]) {
                    opts.skipped.add(depPath);
                }
            }
            else {
                opts.skipped.delete(depPath);
                ctx.pickedPackages[relDepPath] = pkgSnapshot;
            }
        }
        const nextRelDepPaths = R.toPairs(Object.assign({}, pkgSnapshot.dependencies, (opts.include.optionalDependencies && pkgSnapshot.optionalDependencies || {})))
            .map(([pkgName, ref]) => dp.refToRelative(ref, pkgName))
            .filter((nodeId) => nodeId !== null);
        pkgAllDeps(ctx, nextRelDepPaths, installable, opts);
    }
}
//# sourceMappingURL=filterByImportersAndEngine.js.map