"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const run_groups_1 = require("run-groups");
const runLifecycleHook_1 = require("./runLifecycleHook");
function runLifecycleHooksConcurrently(stages, importers, childConcurrency, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const importersByBuildIndex = new Map();
        for (const importer of importers) {
            if (!importersByBuildIndex.has(importer.buildIndex)) {
                importersByBuildIndex.set(importer.buildIndex, [importer]);
            }
            else {
                importersByBuildIndex.get(importer.buildIndex).push(importer);
            }
        }
        const sortedBuildIndexes = Array.from(importersByBuildIndex.keys()).sort();
        const groups = sortedBuildIndexes.map((buildIndex) => {
            const importers = importersByBuildIndex.get(buildIndex);
            return importers.map((importer) => () => __awaiter(this, void 0, void 0, function* () {
                const runLifecycleHookOpts = {
                    depPath: importer.prefix,
                    pkgRoot: importer.prefix,
                    rawNpmConfig: opts.rawNpmConfig,
                    rootNodeModulesDir: importer.modulesDir,
                    stdio: opts.stdio,
                    unsafePerm: opts.unsafePerm,
                };
                for (const stage of stages) {
                    if (!importer.pkg.scripts || !importer.pkg.scripts[stage])
                        continue;
                    yield runLifecycleHook_1.default(stage, importer.pkg, runLifecycleHookOpts);
                }
            }));
        });
        yield run_groups_1.default(childConcurrency, groups);
    });
}
exports.default = runLifecycleHooksConcurrently;
//# sourceMappingURL=runLifecycleHooksConcurrently.js.map