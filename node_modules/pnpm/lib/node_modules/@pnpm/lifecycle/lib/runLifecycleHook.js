"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_loggers_1 = require("@pnpm/core-loggers");
const lifecycle = require("@zkochan/npm-lifecycle");
function noop() { } // tslint:disable-line:no-empty
function runLifecycleHook(stage, pkg, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const optional = opts.optional === true;
        if (opts.stdio !== 'inherit') {
            core_loggers_1.lifecycleLogger.debug({
                depPath: opts.depPath,
                optional,
                script: pkg.scripts[stage],
                stage,
                wd: opts.pkgRoot,
            });
        }
        return lifecycle(pkg, stage, opts.pkgRoot, {
            config: opts.rawNpmConfig,
            dir: opts.rootNodeModulesDir,
            log: {
                clearProgress: noop,
                info: noop,
                level: opts.stdio === 'inherit' ? undefined : 'silent',
                pause: noop,
                resume: noop,
                showProgress: noop,
                silly: npmLog,
                verbose: npmLog,
                warn: noop,
            },
            runConcurrently: true,
            stdio: opts.stdio || 'pipe',
            unsafePerm: opts.unsafePerm,
        });
        function npmLog(prefix, logid, stdtype, line) {
            switch (stdtype) {
                case 'stdout':
                case 'stderr':
                    core_loggers_1.lifecycleLogger.debug({
                        depPath: opts.depPath,
                        line: line.toString(),
                        stage,
                        stdio: stdtype,
                        wd: opts.pkgRoot,
                    });
                    return;
                case 'Returned: code:':
                    if (opts.stdio === 'inherit') {
                        // Preventing the pnpm reporter from overriding the project's script output
                        return;
                    }
                    const code = arguments[3];
                    core_loggers_1.lifecycleLogger.debug({
                        depPath: opts.depPath,
                        exitCode: code,
                        optional,
                        stage,
                        wd: opts.pkgRoot,
                    });
                    return;
            }
        }
    });
}
exports.default = runLifecycleHook;
//# sourceMappingURL=runLifecycleHook.js.map