"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fetch_from_npm_registry_1 = require("fetch-from-npm-registry");
const fs = require("graceful-fs");
const mkdirp = require("mkdirp-promise");
const path = require("path");
const pathTemp = require("path-temp");
const retry = require("retry");
const rimraf = require("rimraf");
const ssri = require("ssri");
const unpackStream = require("unpack-stream");
const urlLib = require("url");
const errorTypes_1 = require("./errorTypes");
exports.default = (gotOpts) => {
    const fetchFromNpmRegistry = fetch_from_npm_registry_1.default(gotOpts);
    const retryOpts = Object.assign({ retries: 2, factor: 10, minTimeout: 1e4, maxTimeout: 6e4 }, gotOpts.retry);
    return function download(url, saveto, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const saveToDir = path.dirname(saveto);
            yield mkdirp(saveToDir);
            // If a tarball is hosted on a different place than the manifest, only send
            // credentials on `alwaysAuth`
            const shouldAuth = opts.auth && (opts.auth.alwaysAuth ||
                !opts.registry ||
                urlLib.parse(url).host === urlLib.parse(opts.registry).host);
            const op = retry.operation(retryOpts);
            return new Promise((resolve, reject) => {
                op.attempt((currentAttempt) => {
                    fetch(currentAttempt)
                        .then(resolve)
                        .catch((err) => {
                        if (err.code === 'E403') {
                            reject(err);
                            return;
                        }
                        if (op.retry(err)) {
                            return;
                        }
                        reject(op.mainError());
                    });
                });
            });
            function fetch(currentAttempt) {
                return __awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield fetchFromNpmRegistry(url, { auth: shouldAuth && opts.auth || undefined }); // tslint:disable-line
                        if (res.status !== 200) {
                            const err = new Error(`${res.status} ${res.statusText}: ${url}`);
                            // tslint:disable
                            err['code'] = `E${res.status}`;
                            err['uri'] = url;
                            err['response'] = res;
                            // tslint:enable
                            throw err;
                        }
                        const contentLength = res.headers.has('content-length') && res.headers.get('content-length');
                        const size = typeof contentLength === 'string'
                            ? parseInt(contentLength, 10)
                            : null;
                        if (opts.onStart) {
                            opts.onStart(size, currentAttempt);
                        }
                        const onProgress = opts.onProgress;
                        let downloaded = 0;
                        res.body.on('data', (chunk) => {
                            downloaded += chunk.length;
                            if (onProgress)
                                onProgress(downloaded);
                        });
                        const tempTarballLocation = pathTemp(saveToDir);
                        const writeStream = fs.createWriteStream(tempTarballLocation);
                        return yield new Promise((resolve, reject) => {
                            const stream = res.body
                                .on('error', reject)
                                .pipe(writeStream)
                                .on('error', reject);
                            const tempLocation = pathTemp(opts.unpackTo);
                            Promise.all([
                                opts.integrity && safeCheckStream(res.body, opts.integrity) || true,
                                unpackStream.local(res.body, tempLocation, {
                                    generateIntegrity: opts.generatePackageIntegrity,
                                    ignore: opts.ignore,
                                }),
                                waitTillClosed({ stream, size, getDownloaded: () => downloaded, url }),
                            ])
                                .then(([integrityCheckResult, filesIndex]) => {
                                if (integrityCheckResult !== true) {
                                    throw integrityCheckResult;
                                }
                                fs.rename(tempTarballLocation, saveto, (err) => {
                                    // ignore
                                });
                                resolve({ tempLocation, filesIndex });
                            })
                                .catch((err) => {
                                rimraf(tempTarballLocation, (err) => {
                                    // ignore
                                });
                                rimraf(tempLocation, (err) => {
                                    // Just ignoring this error
                                    // A redundant stage folder won't break anything
                                });
                                reject(err);
                            });
                        });
                    }
                    catch (err) {
                        err.attempts = currentAttempt;
                        err.resource = url;
                        throw err;
                    }
                });
            }
        });
    };
};
function safeCheckStream(stream, integrity) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield ssri.checkStream(stream, integrity);
            return true;
        }
        catch (err) {
            return err;
        }
    });
}
function waitTillClosed(opts) {
    return new Promise((resolve, reject) => {
        opts.stream.on('close', () => {
            const downloaded = opts.getDownloaded();
            if (opts.size !== null && opts.size !== downloaded) {
                const err = new errorTypes_1.BadTarballError({
                    expectedSize: opts.size,
                    receivedSize: downloaded,
                    tarballUrl: opts.url,
                });
                reject(err);
                return;
            }
            resolve();
        });
    });
}
//# sourceMappingURL=createDownloader.js.map