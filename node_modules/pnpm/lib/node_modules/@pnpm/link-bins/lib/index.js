"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_bins_1 = require("@pnpm/package-bins");
const read_package_json_1 = require("@pnpm/read-package-json");
const cmdShim = require("@zkochan/cmd-shim");
const isWindows = require("is-windows");
const mkdirp = require("mkdirp-promise");
const Module = require("module");
const fs = require("mz/fs");
const normalizePath = require("normalize-path");
const path = require("path");
const R = require("ramda");
const getPkgDirs_1 = require("./getPkgDirs");
const IS_WINDOWS = isWindows();
const EXECUTABLE_SHEBANG_SUPPORTED = !IS_WINDOWS;
const POWER_SHELL_IS_SUPPORTED = IS_WINDOWS;
exports.default = (modules, binPath, opts) => __awaiter(this, void 0, void 0, function* () {
    const pkgDirs = yield getPkgDirs_1.default(modules, opts.warn);
    const allCmds = R.unnest((yield Promise.all(pkgDirs
        .map(normalizePath)
        .map((target) => getPackageBins(target, opts.warn))))
        .filter((cmds) => cmds.length));
    return linkBins(allCmds, binPath, opts);
});
function linkBinsOfPackages(pkgs, binsTarget, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!pkgs.length)
            return;
        const allCmds = R.unnest((yield Promise.all(pkgs
            .map((pkg) => getPackageBinsFromPackageJson(pkg.manifest, pkg.location))))
            .filter((cmds) => cmds.length));
        return linkBins(allCmds, binsTarget, opts);
    });
}
exports.linkBinsOfPackages = linkBinsOfPackages;
function linkBins(allCmds, binPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!allCmds.length)
            return;
        yield mkdirp(binPath);
        const [cmdsWithOwnName, cmdsWithOtherNames] = R.partition((cmd) => cmd.ownName, allCmds);
        yield Promise.all(cmdsWithOwnName.map((cmd) => linkBin(cmd, binPath)));
        const usedNames = R.fromPairs(cmdsWithOwnName.map((cmd) => [cmd.name, cmd.name]));
        yield Promise.all(cmdsWithOtherNames.map((cmd) => {
            if (usedNames[cmd.name]) {
                opts.warn(`Cannot link bin "${cmd.name}" of "${cmd.pkgName}" to "${binPath}". A package called "${usedNames[cmd.name]}" already has its bin linked.`);
                return;
            }
            usedNames[cmd.name] = cmd.pkgName;
            return linkBin(cmd, binPath);
        }));
    });
}
function getPackageBins(target, warn) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkg = yield safeReadPkg(target);
        if (!pkg) {
            warn(`There's a directory in node_modules without package.json: ${target}`);
            return [];
        }
        return getPackageBinsFromPackageJson(pkg, target);
    });
}
function getPackageBinsFromPackageJson(pkgJson, pkgPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const cmds = yield package_bins_1.default(pkgJson, pkgPath);
        return cmds.map((cmd) => (Object.assign({}, cmd, { ownName: cmd.name === pkgJson.name, pkgName: pkgJson.name })));
    });
}
function linkBin(cmd, binPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const externalBinPath = path.join(binPath, cmd.name);
        if (EXECUTABLE_SHEBANG_SUPPORTED) {
            yield fs.chmod(cmd.path, 0o755);
        }
        const nodePath = yield getBinNodePaths(cmd.path);
        return cmdShim(cmd.path, externalBinPath, {
            createPwshFile: POWER_SHELL_IS_SUPPORTED,
            nodePath,
        });
    });
}
function getBinNodePaths(target) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetRealPath = yield fs.realpath(target);
        return R.union(Module._nodeModulePaths(targetRealPath), Module._nodeModulePaths(target));
    });
}
function safeReadPkg(pkgPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield read_package_json_1.fromDir(pkgPath);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return null;
            }
            throw err;
        }
    });
}
//# sourceMappingURL=index.js.map