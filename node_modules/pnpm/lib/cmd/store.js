"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const store_path_1 = require("@pnpm/store-path");
const archy = require("archy");
const supi_1 = require("supi");
const createStoreController_1 = require("../createStoreController");
const errorTypes_1 = require("../errorTypes");
const help_1 = require("./help");
class StoreStatusError extends errorTypes_1.PnpmError {
    constructor(modified) {
        super('MODIFIED_DEPENDENCY', '');
        this.modified = modified;
    }
}
function default_1(input, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let store;
        switch (input[0]) {
            case 'status':
                return statusCmd(opts);
            case 'prune':
                store = yield createStoreController_1.default(opts);
                const storePruneOptions = Object.assign(opts, {
                    store: store.path,
                    storeController: store.ctrl,
                });
                return supi_1.storePrune(storePruneOptions);
            case 'add':
                store = yield createStoreController_1.default(opts);
                return supi_1.storeAdd(input.slice(1), {
                    prefix: opts.prefix,
                    registry: opts.registry,
                    reporter: opts.reporter,
                    storeController: store.ctrl,
                    tag: opts.tag,
                    verifyStoreIntegrity: opts.verifyStoreIntegrity,
                });
            case 'usages':
                store = yield createStoreController_1.default(opts);
                const packageSelectors = input.slice(1);
                const packageUsagesBySelectors = yield supi_1.storeUsages(packageSelectors, {
                    reporter: opts.reporter,
                    storeController: store.ctrl,
                });
                prettyPrintUsages(packageSelectors, packageUsagesBySelectors);
                return;
            default:
                help_1.default(['store']);
                if (input[0]) {
                    const err = new Error(`"store ${input[0]}" is not a pnpm command. See "pnpm help store".`);
                    err['code'] = 'ERR_PNPM_INVALID_STORE_COMMAND'; // tslint:disable-line:no-string-literal
                    throw err;
                }
        }
    });
}
exports.default = default_1;
function statusCmd(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const modifiedPkgs = yield supi_1.storeStatus(Object.assign(opts, {
            store: yield store_path_1.default(opts.prefix, opts.store),
        }));
        if (!modifiedPkgs || !modifiedPkgs.length) {
            logger_1.default.info({
                message: 'Packages in the store are untouched',
                prefix: opts.prefix,
            });
            return;
        }
        throw new StoreStatusError(modifiedPkgs);
    });
}
/**
 * Uses archy to output package usages in a directory-tree like format.
 * @param packageUsages a list of PackageUsage, one per query
 */
function prettyPrintUsages(selectors, packageUsagesBySelectors) {
    // Create nodes for top level usage response
    const packageUsageNodes = selectors.map((selector) => {
        // Create label for root node
        const label = `Package: ${selector}`;
        if (!packageUsagesBySelectors[selector].length) {
            // If not found in store, just output string
            return {
                label,
                nodes: [
                    'Not found in store'
                ]
            };
        }
        // This package was found in the store, create children for all package ids
        const foundPackagesNodes = packageUsagesBySelectors[selector].map((foundPackage) => {
            const label = `Package in store: ${foundPackage.packageId}`;
            // Now create children for all locations this package id is used
            const locations = foundPackage.usages;
            const locationNodes = locations.map(location => {
                return {
                    label: 'Project with dependency: ' + location
                };
            });
            // Now create node for the package found in the store
            return {
                label,
                nodes: locationNodes.length === 0 ? ['No pnpm projects using this package'] : locationNodes
            };
        });
        // Now create node for the original query
        return {
            label,
            nodes: foundPackagesNodes
        };
    });
    const rootTrees = packageUsageNodes.map(node => archy(node));
    rootTrees.forEach(tree => logger_1.storeLogger.info(tree));
}
//# sourceMappingURL=store.js.map